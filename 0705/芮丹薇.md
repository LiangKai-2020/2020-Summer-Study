#Go语言

##基本语法

###Go语言整型（整数类型）

Go语言同时提供了有符号和无符号的整数类型，其中包括 int8、int16、int32 和 int64 四种有符号整数类型，分别对应 8、16、32、64位大小的有符号整数，与此对应的是 uint8、uint16、uint32 和 uint64 四种无符号整数类型。  
此外还有两种整数类型 int 和 uint，它们分别对应特定 CPU 平台的字长，其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。int 和 uint 所能表示的整数大小会在 32bit 或 64bit 之间变化。      
用来表示 Unicode 字符的 rune 类型和 int32 类型是等价的，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。同样，byte 和 uint8 也是等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数。   
最后，还有一种无符号的整数类型 uintptr，它没有指定具体的 bit 大小但是足以容纳指针。uintptr 类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。  
尽管在某些特定的运行环境下 int、uint 和 uintptr 的大小可能相等，但是它们依然是不同的类型，比如 int 和 int32，虽然 int 类型的大小也可能是 32 bit，但是在需要把 int 类型当做 int32 类型使用的时候必须显示的对类型进行转换，反之亦然。  
Go语言中有符号整数采用 2 的补码形式表示，也就是最高 bit 位用来表示符号位，一个 n-bit 的有符号数的取值范围是从 -2(n-1) 到 2(n-1)-1。无符号整数的所有 bit 位都用于表示非负数，取值范围是 0 到 2n-1。例如，int8 类型整数的取值范围是从 -128 到 127，而 uint8 类型整数的取值范围是从 0 到 255。  
###Go语言浮点类型（小数类型）

Go语言提供了两种精度的浮点数 float32 和 float64，它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持  
这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：  
1)常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；  
2)常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；  
3)float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。  
一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。  
var f float32 = 16777216 // 1 << 24  
fmt.Println(f == f+1)    // "true"!  
浮点数在声明的时候可以只写整数部分或者小数部分：  
const e = .718 // 0.718  
const f = 1.     // 1  
很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：  
const Avogadro = 6.02214129e23  
const Planck   = 6.62606957e-34  
用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数  
![](https://m.qpic.cn/psc?/V10OQot13yzIbG/ZUXCJANDCZJwMw9eDcmXBSHnUkQTmFx*D4djAfPRMe9OrNYHdJFWxuzN3kTwA*Ci0jddZXVEomScJ*mhf7toaQ!!/mnull&bo=hwG4AAAAAAADBxw!&rf=photolist&t=5)  
运行结果如下所示：  
3.141593  
3.14  
###Go语言复数    
在计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。
Go语言中复数的类型有两种，分别是  complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。 复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。   
声明复数的语法格式如下所示：  
var name complex128 = complex(x, y)  
其中 name 为复数的变量名，complex128 为复数的类型，“=”后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。  
上面的声明语句也可以简写为下面的形式:  
name := complex(x, y)  
对于一个复数z := complex(x, y)，可以通过Go语言的内置函数real(z) 来获得该复数的实部，也就是 x；通过imag(z) 获得该复数的虚部，也就是 y。  
###Go语言bool类型（布尔类型）    
一个布尔类型的值只有两种：true 或 false。if 和 for 语句的条件部分都是布尔类型的值，并且==和<等比较操作也会产生布尔型的值。!对应逻辑非操作，因此!true的值为 false，更复杂一些的写法是(!true==false) ==true，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 x 来表示x==true。  
var aVar = 10  
aVar == 5  // false  
aVar == 10 // true  
aVar != 5  // true  
aVar != 10 // false  
Go语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较.  
布尔值可以和 &&和 ||操作符结合，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：  
s != "" && s[0] == 'x'  
其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。  
因为&&的优先级比||高,所以下面的布尔表达式可以不加小括号：  
if 'a' <= c && c <= 'z' ||  
 'A' <= c && c <= 'Z' ||  
'0' <= c && c <= '9' {  
// ...ASCII字母或数字...  
}  
布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用 if 语句显式的进行转换：  
i := 0  
 if b {  
    i = 1  
}  
如果经常做类似的转换，可以将转换的代码封装成一个函数：  
![](https://m.qpic.cn/psc?/V10OQot13yzIbG/ZUXCJANDCZJwMw9eDcmXBeCgzHsHHl6HzmRguTkecQnAJ91z3jQ2j7Lg9wxqLg5NCV1rZF539TtFJMlL7Lh.oQ!!/mnull&bo=vAGfAAAAAAADBwA!&rf=photolist&t=5)    
数字到布尔型的逆转换非常简单，为了保持对称，可以封装一个函数：    
func itob(i int) bool { return i != 0 }  
Go语言中不允许将整型强制转换为布尔型，如下：  
var n bool  
fmt.Println(int(n) * 2)    
###Go语言字符串    
一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列。    
####定义字符串  
可以使用双引号""来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，和C语言类似，常用的转义字符包括：  
\n：换行符  
\r：回车符  
\t：tab 键  
\u：Unicode 字符  
\\：反斜杠自身  
![](https://m.qpic.cn/psc?/V10OQot13yzIbG/ZUXCJANDCZJwMw9eDcmXBdvPs9T5GjRn2szFBZXRDvEJPwogx1VaK2uoF7X3X00RYjliIujU*R3.7HbeCWSKYA!!/mnull&bo=QQKnAAAAAAADB8Y!&rf=photolist&t=5)  
结果如下：  
C语言中文网  
Go语言教程  
一般的比较运算符（==、!=、<、<=、>=、>）是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数 len() 来获取，例如 len(str)。  
字符串的内容（纯字节）可以通过标准索引法来获取，在方括号[ ]内写入索引，索引从 0 开始计数，和C语言类似：  
字符串 str 的第 1 个字节：str[0]  
第 i 个字节：str[i - 1]  
####字符串拼接符“+”和“+=”  
两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。将 s2 追加到 s1 尾部并生成一个新的字符串 s。 因为编译器会在行尾自动补全分号，所以拼接字符串用的加号“+”必须放在第一行末尾。  
str := "Beginning of the string " +
"second part of the string"  
也可以使用“+=”来对字符串进行拼接：  
s := "hel" + "lo,"  
s += "world!"  
fmt.Println(s)  
输出“hello, world!”    
####定义多行字符串  
在Go语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量，这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用反引号，在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。  
在`间的所有代码均不会被编译器识别，而只是作为字符串的一部分。  
###Go语言字符类型  
字符串中的每一个元素叫做“字符”，Go语言的字符有以下两种：
一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。  
另一种是 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。  
在 ASCII 码表中，A 的值是 65，使用 16 进制表示则为 41。  
var ch byte = 65 或 var ch byte = '\x41'  
这俩种写法是等效的，另外一种可能的写法是 \后面紧跟着长度为 3 的八进制数，例如 \377。   
格式化说明符%c用于表示字符，当和字符配合使用时，%v或%d会输出用于表示该字符的整数，%U 输出格式为 U+hhhh 的字符串。  
Unicode 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（ ch 代表字符）：  
判断是否为字母：unicode.IsLetter(ch)  
判断是否为数字：unicode.IsDigit(ch)  
判断是否为空白符号：unicode.IsSpace(ch)    
###Go语言数据类型转换  
在必要的情况下，一个类型的值可以被转换成另一种类型的值。由于Go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：  
valueOfTypeB = typeB(valueOfTypeA)  
类型 B 的值 = 类型 B(类型 A 的值)  
例如a := 5.0  
b := int(a)  
类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失的情况。只有相同类型的变量之间可以进行相互转换（如将 int16 转换成 int32 ），不同类型的变量相互转换时会引发编译错误。浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。